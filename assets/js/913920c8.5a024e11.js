"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[930],{3150(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"overview/overview_advanced","title":"Advanced Usage","description":"Host Filtering with Subdomains","source":"@site/../scurl-detector-docs/target/mdoc/overview/overview_advanced.md","sourceDirName":"overview","slug":"/overview/overview_advanced","permalink":"/scurl-detector/overview/overview_advanced","draft":false,"unlisted":false,"editUrl":"https://github.com/lambdaworks/scurl-detector/edit/main/docs/overview/overview_advanced.md","tags":[],"version":"current","frontMatter":{"id":"overview_advanced","title":"Advanced Usage"},"sidebar":"docs","previous":{"title":"Detection Options","permalink":"/scurl-detector/overview/overview_options"},"next":{"title":"API Reference","permalink":"/scurl-detector/overview/overview_api"}}');var r=n(4848),l=n(8453);const a={id:"overview_advanced",title:"Advanced Usage"},i=void 0,c={},o=[{value:"Host Filtering with Subdomains",id:"host-filtering-with-subdomains",level:2},{value:"Subdomain Matching Rules",id:"subdomain-matching-rules",level:3},{value:"Denying Specific Subdomains",id:"denying-specific-subdomains",level:3},{value:"Explicit Subdomain Filtering",id:"explicit-subdomain-filtering",level:3},{value:"Protocol-Relative URLs",id:"protocol-relative-urls",level:2},{value:"Missing Scheme Handling",id:"missing-scheme-handling",level:2},{value:"IPv4 and IPv6 Support",id:"ipv4-and-ipv6-support",level:2},{value:"URL Encoding and Special Characters",id:"url-encoding-and-special-characters",level:2},{value:"Email Address Filtering",id:"email-address-filtering",level:2},{value:"Handling URLs with User Info",id:"handling-urls-with-user-info",level:2},{value:"Custom Detection Pipelines",id:"custom-detection-pipelines",level:2},{value:"Processing Large Text",id:"processing-large-text",level:2},{value:"Validating Extracted URLs",id:"validating-extracted-urls",level:2},{value:"Extracting and Categorizing URLs",id:"extracting-and-categorizing-urls",level:2},{value:"Integration with HTTP Clients",id:"integration-with-http-clients",level:2},{value:"Thread Safety",id:"thread-safety",level:2},{value:"Performance Optimization Tips",id:"performance-optimization-tips",level:2}];function d(e){const t={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"host-filtering-with-subdomains",children:"Host Filtering with Subdomains"}),"\n",(0,r.jsx)(t.p,{children:"The URL detector provides intelligent subdomain handling when filtering hosts."}),"\n",(0,r.jsx)(t.h3,{id:"subdomain-matching-rules",children:"Subdomain Matching Rules"}),"\n",(0,r.jsx)(t.p,{children:"When you specify a host, the detector automatically handles subdomains intelligently:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import io.lambdaworks.detection.UrlDetector\nimport io.lemonlabs.uri.Host\n\n// Specifying "example.com" will match:\n// - example.com\n// - www.example.com (www is implicit)\n// - api.example.com\n// - any.subdomain.example.com\n\nval detector = UrlDetector.default.withAllowed(Host.parse("example.com"))\nval urls = detector.extract("""\n  https://example.com\n  https://www.example.com\n  https://api.example.com\n  https://cdn.us-east.example.com\n""")\n\n// All URLs will be extracted\n'})}),"\n",(0,r.jsx)(t.h3,{id:"denying-specific-subdomains",children:"Denying Specific Subdomains"}),"\n",(0,r.jsx)(t.p,{children:"You can deny specific subdomains while allowing others:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'val detector = UrlDetector.default\n  .withAllowed(Host.parse("example.com"))\n  .withDenied(Host.parse("ads.example.com"))\n\nval text = """\n  https://example.com\n  https://api.example.com\n  https://ads.example.com\n  https://tracking.ads.example.com\n"""\n\nval urls = detector.extract(text)\n// Returns: example.com, api.example.com\n// Excludes: ads.example.com, tracking.ads.example.com\n'})}),"\n",(0,r.jsx)(t.h3,{id:"explicit-subdomain-filtering",children:"Explicit Subdomain Filtering"}),"\n",(0,r.jsx)(t.p,{children:"To match only a specific subdomain (not its children):"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'// This will match api.example.com and www.api.example.com\n// but NOT v1.api.example.com\nval detector = UrlDetector.default.withAllowed(Host.parse("api.example.com"))\n'})}),"\n",(0,r.jsx)(t.h2,{id:"protocol-relative-urls",children:"Protocol-Relative URLs"}),"\n",(0,r.jsxs)(t.p,{children:["The detector handles protocol-relative URLs (starting with ",(0,r.jsx)(t.code,{children:"//"}),") by converting them to HTTP:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'val detector = UrlDetector.default\nval urls = detector.extract("Load //cdn.example.com/script.js")\n\n// Returns: http://cdn.example.com/script.js\n'})}),"\n",(0,r.jsx)(t.h2,{id:"missing-scheme-handling",children:"Missing Scheme Handling"}),"\n",(0,r.jsx)(t.p,{children:"URLs without schemes are automatically assigned the HTTP scheme:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'val detector = UrlDetector.default\nval urls = detector.extract("Visit example.com and www.github.com")\n\n// Returns:\n// - http://example.com\n// - http://www.github.com\n'})}),"\n",(0,r.jsx)(t.h2,{id:"ipv4-and-ipv6-support",children:"IPv4 and IPv6 Support"}),"\n",(0,r.jsx)(t.p,{children:"The detector recognizes both IPv4 and IPv6 addresses:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'val detector = UrlDetector.default\n\n// IPv4\nval ipv4Urls = detector.extract("API at http://192.168.1.1:8080/api")\n// Returns: http://192.168.1.1:8080/api\n\n// IPv6\nval ipv6Urls = detector.extract("Server at http://[2001:db8::1]:8080/")\n// Returns: http://[2001:db8::1]:8080/\n'})}),"\n",(0,r.jsx)(t.h2,{id:"url-encoding-and-special-characters",children:"URL Encoding and Special Characters"}),"\n",(0,r.jsx)(t.p,{children:"The detector handles URL-encoded characters, particularly encoded spaces:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'val detector = UrlDetector.default\nval urls = detector.extract("Download from https://example.com/my%20file.pdf")\n\n// The URL is properly extracted with encoding preserved\n'})}),"\n",(0,r.jsx)(t.h2,{id:"email-address-filtering",children:"Email Address Filtering"}),"\n",(0,r.jsx)(t.p,{children:"The detector automatically filters out email addresses to avoid false positives:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'val detector = UrlDetector.default\nval text = "Contact us at support@example.com or visit https://example.com"\n\nval urls = detector.extract(text)\n// Returns only: https://example.com\n// Excludes: support@example.com\n'})}),"\n",(0,r.jsx)(t.h2,{id:"handling-urls-with-user-info",children:"Handling URLs with User Info"}),"\n",(0,r.jsx)(t.p,{children:"URLs containing user credentials require explicit schemes:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'val detector = UrlDetector.default\n\n// This will be extracted (has explicit scheme)\nval withScheme = detector.extract("ftp://user:pass@ftp.example.com")\n// Returns: ftp://user:pass@ftp.example.com\n\n// This will be rejected (no scheme with user info)\nval noScheme = detector.extract("user:pass@example.com")\n// Returns: empty set (rejected as potentially an email variant)\n'})}),"\n",(0,r.jsx)(t.h2,{id:"custom-detection-pipelines",children:"Custom Detection Pipelines"}),"\n",(0,r.jsx)(t.p,{children:"You can create reusable detector configurations for different use cases:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'object Detectors {\n  // For public web scraping - only allow common public domains\n  lazy val publicWeb: UrlDetector = UrlDetector(UrlDetectorOptions.Html)\n    .withDenied(\n      Host.parse("localhost"),\n      Host.parse("127.0.0.1"),\n      Host.parse("0.0.0.0")\n    )\n\n  // For API response parsing\n  lazy val apiResponses: UrlDetector = UrlDetector(UrlDetectorOptions.Json)\n\n  // For development environments\n  lazy val development: UrlDetector =\n    UrlDetector(UrlDetectorOptions.AllowSingleLevelDomain)\n\n  // For secure contexts - HTTPS only (filter applied post-extraction)\n  def httpsOnly: UrlDetector = UrlDetector.default\n\n  def extractHttpsOnly(text: String): Set[AbsoluteUrl] = {\n    httpsOnly.extract(text).filter(_.schemeOption.contains("https"))\n  }\n}\n\n// Usage\nval webUrls = Detectors.publicWeb.extract(htmlContent)\nval apiUrls = Detectors.apiResponses.extract(jsonResponse)\nval localUrls = Detectors.development.extract(configFile)\nval secureUrls = Detectors.extractHttpsOnly(userInput)\n'})}),"\n",(0,r.jsx)(t.h2,{id:"processing-large-text",children:"Processing Large Text"}),"\n",(0,r.jsx)(t.p,{children:"For large documents, consider chunking the text and processing in parallel:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:"import scala.concurrent.{Future, ExecutionContext}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ndef extractUrlsParallel(text: String, chunkSize: Int = 10000)\n                       (implicit ec: ExecutionContext): Future[Set[AbsoluteUrl]] = {\n  val chunks = text.grouped(chunkSize).toSeq\n  val detector = UrlDetector.default\n\n  val futures = chunks.map { chunk =>\n    Future {\n      detector.extract(chunk)\n    }\n  }\n\n  Future.sequence(futures).map(_.flatten.toSet)\n}\n\n// Usage\nval largeText = // ... load large document\nval urlsFuture = extractUrlsParallel(largeText)\n"})}),"\n",(0,r.jsx)(t.h2,{id:"validating-extracted-urls",children:"Validating Extracted URLs"}),"\n",(0,r.jsx)(t.p,{children:"You can add additional validation after extraction:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import io.lemonlabs.uri.AbsoluteUrl\n\ndef validateUrls(urls: Set[AbsoluteUrl]): Set[AbsoluteUrl] = {\n  urls.filter { url =>\n    // Only allow standard ports\n    url.port.forall(p => p == 80 || p == 443 || p == 8080)\n  }.filter { url =>\n    // Only allow certain schemes\n    url.schemeOption.exists(s => Set("http", "https").contains(s))\n  }.filter { url =>\n    // Exclude URLs with certain path patterns\n    !url.path.toString().contains("/admin/")\n  }\n}\n\nval detector = UrlDetector.default\nval allUrls = detector.extract(text)\nval validUrls = validateUrls(allUrls)\n'})}),"\n",(0,r.jsx)(t.h2,{id:"extracting-and-categorizing-urls",children:"Extracting and Categorizing URLs"}),"\n",(0,r.jsx)(t.p,{children:"Group and categorize extracted URLs:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'case class UrlCategory(\n  apis: Set[AbsoluteUrl],\n  assets: Set[AbsoluteUrl],\n  pages: Set[AbsoluteUrl],\n  other: Set[AbsoluteUrl]\n)\n\ndef categorizeUrls(urls: Set[AbsoluteUrl]): UrlCategory = {\n  val (apis, rest1) = urls.partition(_.path.toString().contains("/api/"))\n  val (assets, rest2) = rest1.partition { url =>\n    val path = url.path.toString().toLowerCase\n    path.endsWith(".css") || path.endsWith(".js") ||\n    path.endsWith(".png") || path.endsWith(".jpg")\n  }\n  val (pages, other) = rest2.partition { url =>\n    val path = url.path.toString().toLowerCase\n    path.isEmpty || path.endsWith(".html") || path.endsWith("/")\n  }\n\n  UrlCategory(apis, assets, pages, other)\n}\n\n// Usage\nval detector = UrlDetector(UrlDetectorOptions.Html)\nval urls = detector.extract(htmlContent)\nval categorized = categorizeUrls(urls)\n\nprintln(s"APIs: ${categorized.apis.size}")\nprintln(s"Assets: ${categorized.assets.size}")\nprintln(s"Pages: ${categorized.pages.size}")\nprintln(s"Other: ${categorized.other.size}")\n'})}),"\n",(0,r.jsx)(t.h2,{id:"integration-with-http-clients",children:"Integration with HTTP Clients"}),"\n",(0,r.jsx)(t.p,{children:"Use extracted URLs with HTTP clients:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'import sttp.client3._\n\ndef validateExtractedUrls(text: String): Future[Map[AbsoluteUrl, Boolean]] = {\n  val detector = UrlDetector.default\n  val urls = detector.extract(text)\n  val backend = HttpURLConnectionBackend()\n\n  val results = urls.map { url =>\n    val request = basicRequest.get(uri"${url.toString}").response(asString)\n    val response = request.send(backend)\n    url -> response.code.isSuccess\n  }.toMap\n\n  Future.successful(results)\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"UrlDetector"})," instances are immutable and thread-safe. You can safely share detector instances across threads:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:"object SharedDetectors {\n  // Safe to use across multiple threads\n  val default: UrlDetector = UrlDetector.default\n  val html: UrlDetector = UrlDetector(UrlDetectorOptions.Html)\n  val json: UrlDetector = UrlDetector(UrlDetectorOptions.Json)\n}\n\n// Safe concurrent usage\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ndef processMultipleTexts(texts: Seq[String]): Future[Seq[Set[AbsoluteUrl]]] = {\n  Future.traverse(texts) { text =>\n    Future {\n      SharedDetectors.default.extract(text)\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"performance-optimization-tips",children:"Performance Optimization Tips"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Reuse Detector Instances"}),": Create detector instances once and reuse them"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Choose Specific Options"}),": Use the most specific detection option for your content type"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Apply Host Filters"}),": If you know you only need specific hosts, apply filters to reduce processing"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Pre-filter Text"}),": If possible, exclude large sections of text that definitely don't contain URLs"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Batch Processing"}),": Process multiple documents with the same detector instance"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:"// Good: Reuse detector instance\nval detector = UrlDetector(UrlDetectorOptions.Json)\nval results = documents.map(doc => detector.extract(doc))\n\n// Less efficient: Create new detector each time\nval results = documents.map { doc =>\n  UrlDetector(UrlDetectorOptions.Json).extract(doc)\n}\n"})})]})}function p(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,t,n){n.d(t,{R:()=>a,x:()=>i});var s=n(6540);const r={},l=s.createContext(r);function a(e){const t=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(l.Provider,{value:t},e.children)}}}]);